# Cursor AI Coding Rules for CSR Web Developer tools

## Project Context
A free collection of web developer tools that work entirely client-side, including:
- **Color Converter**: Convert between different color formats (HEX, RGB, HSL, OKLCH)
- **Base64 Encoder/Decoder**: Encode and decode Base64 strings
- **Image Converter**: Convert between different image formats
- **Image Resize**: Resize images while maintaining aspect ratio
- **Unix Timestamp Converter**: Convert between Unix timestamps and human-readable dates
- **PX to REM Converter**: Convert pixel values to REM units

Built with React 19, TypeScript, Tailwind CSS v4, Radix UI, Motion One, and Zustand for a modern, performant developer experience.

## Code Style & Standards

### TypeScript
- **Always use TypeScript with strict mode**
- Prefer type inference when possible, explicit types when clarity needed
- Use proper interfaces for object shapes
- **Avoid `any` type, use `unknown` or proper types**
- Export types alongside implementation when creating reusable components

### React/Frontend (apps/interface)
- **Use functional components with hooks**
- **Prefer composition over inheritance**
- **Follow React 19 best practices (no more defaultProps, use built-in types)**
- Use Zustand for state management with proper TypeScript types
- Implement proper error boundaries
- **Use Radix UI as the base component library for Tailwind CSS compatibility**
- **Extend Radix UI components with Tailwind utility classes for styling**
- **Leverage Radix UI's unstyled components for maximum Tailwind flexibility**

### Tailwind CSS (v4)
- **Use Tailwind CSS v4 with CSS-based configuration in `src/index.css`**
- **Configure custom theme using @theme directive**: colors, typography, shadows, breakpoints
- **OKLCH color system**: Use OKLCH for consistent, perceptual color values
- **Custom design tokens**: Primary/secondary colors, semantic colors (info, warning, success, error)
- **Typography system**: Predefined text styles (heading-1 through heading-6, body variants)
- **PREFER PURE TAILWIND CLASSES**: Avoid separate CSS files for component styling
- **Use utility classes over custom CSS** except for reusable component patterns
- **Responsive breakpoints**: tablet (48rem), laptop (80rem), desktop (120rem)
- **Mobile-first responsive design** with consistent breakpoint usage
- **Custom utilities**: `.bg-pixel-texture`, `.bg-grid-texture` for visual effects
- **Component classes**: `.input` and `.popover` for consistent form styling
- **Prefer Motion One for animations**: Use Tailwind `data-[state]` only for state styling
- **Dark mode by default**: Use `color-scheme: dark` with light text on dark backgrounds

### File Naming & Structure
- **Use kebab-case for file names (app-version.ts)**
- **Use PascalCase for component files (HomePage.tsx)**
- **Use camelCase for utilities and hooks (useAppVersion.ts)**
- Group related files in feature directories
- Use index.ts files for clean exports

### Code Organization
- **Keep components focused and single-responsibility**
- **Extract custom hooks for reusable logic**
- **Feature-based organization**: Each tool has its own directory in `src/components/feature/`
- **Type organization**: Types organized in `src/types/` with feature-specific subdirectories
- **Hook organization**: Custom hooks in `src/hooks/` with feature grouping
- **Consistent import ordering**: External dependencies → internal modules → relative imports
- **Index file exports**: Use `index.ts` files for clean re-exports and barrel patterns
- **Lazy loading imports**: Use dynamic imports for tool components to optimize bundle splitting
- **Avoid separate CSS files**: Use Tailwind classes directly in components

### Icon System
- **Write SVG icon components in `src/components/common/icon/` directory**
- **Accept only size prop (number, default: '1em') for direct height/width control**
- **Use stroke="currentColor" for theme compatibility and dark mode support**
- **Keep icons simple and reusable with consistent 24x24 viewBox**
- **Export all icons from index.ts for centralized imports**
- **Icons follow naming pattern**: `{Name}Icon.tsx` (e.g., `PlusIcon.tsx`, `CopyIcon.tsx`)

### Project Architecture
- **Single Vite application** with TypeScript and React 19
- **Feature-based component organization** in `src/components/feature/`
- **Common reusable components** in `src/components/common/`
- **Lazy loading** for tool components to optimize bundle size
- **Client-side only** - no server dependencies or backend API calls

### Development Commands
- `pnpm dev` - Start development server on port 5173
- `pnpm build` - Build for production (TypeScript compilation + Vite build)
- `pnpm lint` - Run ESLint with Perfectionist plugin for import sorting
- `pnpm preview` - Preview production build locally
- `pnpm test` - Run Vitest unit tests

### Dependencies & Tech Stack
- **Package Management**: pnpm (version 10.11.0+)
- **Runtime**: Node.js 24.5.0+
- **React**: 19.1.1 with functional components and hooks
- **Routing**: React Router 7.7.1
- **State Management**: Zustand 5.0.7 for client state
- **Styling**: Tailwind CSS 4.1.11 with Tailwind Variants 2.1.0
- **UI Components**: Radix UI (Dialog, Select, Tabs, Toast)
- **Animations**: Motion One 12.23.12 for React animations
- **File Processing**: JSZip 3.10.1 for archive operations
- **Build Tool**: Vite 7.0.6 with React plugin
- **Linting**: ESLint 9.32.0 with Perfectionist, Prettier, and React plugins
- **Testing**: Vitest 3.2.4

## AI Assistant Guidelines

### When Writing Code
1. Implement proper TypeScript types
2. Follow existing ESLint configuration
3. Implement responsive design with Tailwind CSS v4
4. Use @theme directive in CSS files for custom configurations
5. **Use Radix UI components as the base, then style with Tailwind utility classes**
6. **Use pure Tailwind classes for component styling instead of separate CSS files**
7. **Prefer Motion One (`motion/react`) for animations, transitions, and presence; avoid Tailwind `animate-*`/`fade-*`/`slide-*` utilities**
8. **Create simple SVG icon components instead of using external icon libraries**

### Code Quality Checks
- Add proper TypeScript types for all functions
- Use semantic HTML and ARIA attributes
- **Ensure all Tailwind classes are properly ordered according to linter rules**
- **Use Motion One for animations; use Tailwind's `data-[state]` only to reflect state in styling**

## Performance Guidelines
- Use lazy loading for React components
- Minimize bundle size with tree shaking
- **Prefer Tailwind's utility classes over custom CSS for better performance**
- **Avoid external dependencies when built-in solutions exist**

## Security Considerations
- Validate all user inputs
- **Use built-in browser features over external libraries when possible**

## Component Styling Best Practices
- **Use Radix UI components as the foundation for all interactive elements**
- **Extend Radix UI components with Tailwind utility classes for styling**
- **Use Tailwind classes directly in components instead of separate CSS files**
- **Leverage Motion One for smooth transitions and presence-based animations**
- **Use semantic class names that match your theme system**
- **Implement responsive design with mobile-first approach**
- **Use backdrop-blur and modern CSS features for enhanced UX**
- **Create reusable component variants using Tailwind's utility patterns**

## Icon Development Guidelines
- **Create icons as simple React components in `src/components/common/icon/`**
- **Use consistent 24x24 viewBox and stroke properties**
- **Make icons theme-aware with `stroke="currentColor"`**
- **Accept only size prop (number, default: '1em') for flexible sizing**
- **Apply size directly to height and width attributes with `size ?? '1em'`**
- **Use standard stroke properties**: `strokeLinecap="round"`, `strokeLinejoin="round"`, `strokeWidth="2"`
- **Keep icon paths simple and optimized for small bundle size**
- **Follow naming convention**: `{Name}Icon.tsx` (PascalCase + Icon suffix)
- **Export from centralized index.ts for clean imports**

## Zustand State Management

- **Primary state library**: Use `zustand` for client-side state. Avoid Redux or heavy contexts for app state.
- **Type safety**: Define clear interfaces for `State` and `Actions`; export a combined `StoreState` type.
- **Store creation**: Use `create<StoreState>()` with functional `set` and `get`. Avoid `any`.
- **Selectors by default**: Always select specific slices, e.g., `useUserStore((s) => s.user)`. Avoid subscribing to full state.
- **Shallow comparison**: When selecting multiple fields, use `shallow` to minimize re-renders.
- **File structure**: Place store files near their feature (e.g., `features/user/use-user-store.ts`). Export from a feature `index.ts` when helpful.
- **Naming**: Name hooks `useXStore` (e.g., `useThemeStore`). Use kebab-case for filenames.
- **Persistence**: If persisting, wrap with `persist` and include `version`, `name`, and `migrate` for safe upgrades. Prefer `localStorage`; fall back safely in SSR.
- **No global side effects**: Do not touch `window` during store initialization. Lazy-read environment in actions only.
- **Testing & reset**: Expose a `reset()` action for tests and storybook to return to initial state.
- **No provider needed**: Do not wrap the app with custom providers for Zustand.
- **Middleware**: Prefer built-in middleware (`persist`, `subscribeWithSelector`) over external helpers.