---
alwaysApply: true
---

# State Management

## Zustand
- **Primary state library**: Use `zustand` for client-side state
- **Type safety**: Define clear interfaces for `State` and `Actions`; export a combined `StoreState` type
- **Store creation**: Use `create<StoreState>()` with functional `set` and `get`. Avoid `any`
- **Selectors by default**: Always select specific slices, e.g., `useUserStore((s) => s.user)`
- **Shallow comparison**: When selecting multiple fields, use `shallow` to minimize re-renders
- **File structure**: Place store files near their feature (e.g., `features/user/use-user-store.ts`)
- **Naming**: Name hooks `useXStore` (e.g., `useThemeStore`). Use kebab-case for filenames
- **Persistence**: If persisting, wrap with `persist` and include `version`, `name`, and `migrate`
- **No global side effects**: Do not touch `window` during store initialization
- **Testing & reset**: Expose a `reset()` action for tests and storybook
- **No provider needed**: Do not wrap the app with custom providers for Zustand
- **Middleware**: Prefer built-in middleware (`persist`, `subscribeWithSelector`)

## Custom Hook Patterns
- **Naming convention**: Use `useX` prefix for custom hooks (e.g., `useCopyToClipboard`)
- **Type exports**: Export hook types alongside implementations (e.g., `UseCopyToClipboard`)
- **Single responsibility**: Each hook should have one clear purpose
- **Error handling**: Implement proper error handling and user feedback
- **Async operations**: Use proper async/await patterns for API calls
- **Dependencies**: List all dependencies explicitly in useEffect and useCallback

## Hook Implementation Examples
```typescript
// ✅ Good custom hook pattern
export const useCopyToClipboard = (): UseCopyToClipboard => {
  const toast = useToast()

  return async (val: string) => {
    await navigator.clipboard.writeText(val)
    toast.toast({
      action: 'add',
      item: { label: 'Copied to clipboard', type: 'success' }
    })
  }
}

// ✅ Good debounce hook pattern
export const useDebounceCallback = <T extends (...args: never[]) => void>(
  callback: T,
  delay: number,
): ((...args: Parameters<T>) => void) => {
  const callbackRef = useRef(callback)
  const timeoutRef = useRef<NodeJS.Timeout>()

  // Update callback ref when callback changes
  useEffect(() => {
    callbackRef.current = callback
  }, [callback])

  return useCallback((...args: Parameters<T>) => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current)
    }

    timeoutRef.current = setTimeout(() => {
      callbackRef.current(...args)
    }, delay)
  }, [delay])
}
```

## TanStack Query
- **Server state management**: Use TanStack Query for data fetching, caching, and synchronization
- **Query keys**: Use consistent, hierarchical query keys for proper cache invalidation
- **Error handling**: Implement proper error boundaries and retry strategies
- **Loading states**: Leverage built-in loading, error, and success states for UI feedback
- **Mutations**: Use `useMutation` for data modifications with optimistic updates when appropriate
- **Cache management**: Configure appropriate stale times and cache lifetimes for different data types
- **Offline support**: Leverage built-in offline capabilities for better user experience
- **DevTools**: Use TanStack Query DevTools in development for debugging cache state
